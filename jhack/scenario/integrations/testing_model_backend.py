"""Vendored TestingModelBackend from ops, so we're no longer reliant on the ops implementation being public."""

# Copyright 2021 Canonical Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Infrastructure to build unit tests for charms using the ops library."""

import dataclasses
import datetime
import fnmatch
import http
import io
import os
import pathlib
import re
import shutil
import signal
import tempfile
import typing
import uuid
from io import IOBase
from ops import charm, model, pebble
from ops.jujucontext import _JujuContext
from ops.model import Container, RelationNotFoundError, StatusName, _NetworkDict
from ops.pebble import ExecProcess
from typing import (
    Any,
    AnyStr,
    BinaryIO,
    Callable,
    ClassVar,
    Dict,
    Iterable,
    List,
    Literal,
    Optional,
    Sequence,
    Set,
    TextIO,
    Tuple,
    TypedDict,
    Union,
    cast,
)

_RelationEntities = TypedDict("_RelationEntities", {"app": str, "units": List[str]})

_RawStatus = TypedDict(
    "_RawStatus",
    {
        "status": StatusName,
        "message": str,
    },
)
_ConfigOption = TypedDict(
    "_ConfigOption",
    {
        "type": Literal["string", "int", "float", "boolean", "secret"],
        "description": str,
        "default": Union[str, int, float, bool],
    },
)
_RawConfig = TypedDict("_RawConfig", {"options": Dict[str, _ConfigOption]})


@dataclasses.dataclass
class ExecArgs:
    """Represent arguments captured from the :meth:`ops.Container.exec` method call.

    These arguments will be passed to the :meth:`Harness.handle_exec` handler function.
    See :meth:`ops.pebble.Client.exec` for documentation of properties.
    """

    command: List[str]
    environment: Dict[str, str]
    working_dir: Optional[str]
    timeout: Optional[float]
    user_id: Optional[int]
    user: Optional[str]
    group_id: Optional[int]
    group: Optional[str]
    stdin: Optional[Union[str, bytes]]
    encoding: Optional[str]
    combine_stderr: bool


@dataclasses.dataclass
class ExecResult:
    """Represents the result of a simulated process execution.

    This class is typically used to return the output and exit code from the
    :meth:`Harness.handle_exec` result or handler function.
    """

    exit_code: int = 0
    stdout: Union[str, bytes] = b""
    stderr: Union[str, bytes] = b""


ExecHandler = Callable[[ExecArgs], Union[None, ExecResult]]


@dataclasses.dataclass(frozen=True)
class ActionOutput:
    """Contains the logs and results from a :meth:`Harness.run_action` call."""

    logs: List[str]
    """Messages generated by the Charm using :meth:`ops.ActionEvent.log`."""

    results: Dict[str, Any]
    """The action's results, as set or updated by :meth:`ops.ActionEvent.set_results`."""


@dataclasses.dataclass()
class _RunningAction:
    name: str
    output: ActionOutput
    parameters: Dict[str, Any]
    failure_message: Optional[str] = None


class _TestingConfig(Dict[str, Union[str, int, float, bool]]):
    """Represents the Juju Config."""

    _supported_types: ClassVar[Dict[str, Any]] = {
        "string": str,
        "boolean": bool,
        "int": int,
        "float": float,
        "secret": str,  # There is some special structure, but they are strings.
    }

    def __init__(self, config: "_RawConfig"):
        super().__init__()
        self._spec = config
        self._defaults = self._load_defaults(config)

        for key, value in self._defaults.items():
            if value is None:
                continue
            self._config_set(key, value)

    @staticmethod
    def _load_defaults(
        charm_config: "_RawConfig",
    ) -> Dict[str, Union[str, int, float, bool]]:
        """Load default values from config.yaml.

        Handle the case where a user doesn't supply explicit config snippets.
        """
        if not charm_config:
            return {}
        cfg: Dict[str, _ConfigOption] = charm_config.get("options", {})
        return {key: value.get("default", None) for key, value in cfg.items()}

    def _config_set(self, key: str, value: Union[str, int, float, bool]):
        # this is only called by the harness itself
        # we don't do real serialization/deserialization, but we do check that the value
        # has the expected type.
        option = self._spec.get("options", {}).get(key)
        if not option:
            raise RuntimeError(
                f"Unknown config option {key}; "
                "not declared in `config.yaml`."
                "Check https://juju.is/docs/sdk/config for the "
                "spec."
            )

        declared_type = option.get("type")
        if not declared_type:
            raise RuntimeError(
                f"Incorrectly formatted `options.yaml`, option {key} "
                "is expected to declare a `type`."
            )

        if declared_type not in self._supported_types:
            raise RuntimeError(
                "Incorrectly formatted `options.yaml`: `type` needs to be one "
                "of [{}], not {}.".format(
                    ", ".join(self._supported_types), declared_type
                )
            )

        if type(value) is not self._supported_types[declared_type]:
            raise RuntimeError(
                f"Config option {key} is supposed to be of type "
                f"{declared_type}, not `{type(value).__name__}`."
            )

        # call 'normal' setattr.
        dict.__setitem__(self, key, value)  # type: ignore

    def __setitem__(self, key: Any, value: Any):
        # if a charm attempts to config[foo] = bar:
        raise TypeError("'ConfigData' object does not support item assignment")


class _TestingRelationDataContents(Dict[str, str]):
    def __setitem__(self, key: str, value: str):
        if not isinstance(key, str):
            raise model.RelationDataError(
                f"relation data keys must be strings, not {type(key)}"
            )
        if not isinstance(value, str):
            raise model.RelationDataError(
                f"relation data values must be strings, not {type(value)}"
            )
        super().__setitem__(key, value)

    def copy(self):
        return _TestingRelationDataContents(super().copy())


@dataclasses.dataclass
class _SecretRevision:
    revision: int
    content: Dict[str, str]


@dataclasses.dataclass
class _Secret:
    id: str
    owner_name: str
    revisions: List[_SecretRevision]
    rotate_policy: Optional[str]
    expire_time: Optional[datetime.datetime]
    label: Optional[str] = None
    description: Optional[str] = None
    tracked: int = 1
    grants: Dict[int, Set[str]] = dataclasses.field(default_factory=dict)
    user_secrets_grants: Set[str] = dataclasses.field(default_factory=set)


class TestingModelBackend:
    """This conforms to the interface for ModelBackend but provides canned data.

    DO NOT use this class directly, it is used by `Harness`_ to drive the model.
    `Harness`_ is responsible for maintaining the internal consistency of the values here,
    as the only public methods of this type are for implementing ModelBackend.
    """

    def __init__(
        self,
        unit_name: str,
        meta: charm.CharmMeta,
        config: "_RawConfig",
        juju_context: _JujuContext,
    ):
        self._juju_context = juju_context
        self.unit_name = unit_name
        self.app_name = self.unit_name.split("/")[0]
        self.model_name = None
        self.model_uuid = str(uuid.uuid4())

        self._harness_tmp_dir = tempfile.TemporaryDirectory(prefix="ops-harness-")
        self._harness_storage_path = (
            pathlib.Path(self._harness_tmp_dir.name) / "storages"
        )
        self._harness_container_path = (
            pathlib.Path(self._harness_tmp_dir.name) / "containers"
        )
        self._harness_storage_path.mkdir()
        self._harness_container_path.mkdir()
        # this is used by the  decorator
        self._calls: List[Tuple[Any, ...]] = []
        self._meta = meta
        # relation name to [relation_ids,...]
        self._relation_ids_map: Dict[str, List[int]] = {}
        # reverse map from relation_id to relation_name
        self._relation_names: Dict[int, str] = {}
        # relation_id: [unit_name,...]
        self._relation_list_map: Dict[int, List[str]] = {}
        # {relation_id: {name: Dict[str: str]}}
        self._relation_data_raw: Dict[int, Dict[str, Dict[str, str]]] = {}
        # {relation_id: {"app": app_name, "units": ["app/0",...]}
        self._relation_app_and_units: Dict[int, _RelationEntities] = {}
        self._config = _TestingConfig(config)
        self._is_leader: bool = False
        # {resource_name: resource_content}
        # where resource_content is (path, content)
        self._resources_map: Dict[str, Tuple[str, Union[str, bytes]]] = {}
        # fixme: understand how this is used and adjust the type
        self._pod_spec: Optional[Tuple[model.K8sSpec, Any]] = None
        self._app_status: _RawStatus = {"status": "unknown", "message": ""}
        self._unit_status: _RawStatus = {"status": "maintenance", "message": ""}
        self._workload_version: Optional[str] = None
        self._resource_dir: Optional[tempfile.TemporaryDirectory[Any]] = None
        # Format:
        # { "storage_name": {"<ID1>": { <other-properties> }, ... }
        # <ID1>: device id that is key for given storage_name
        # Initialize the _storage_list with values present on metadata.yaml
        self._storage_list: Dict[str, Dict[int, Dict[str, Any]]] = {
            k: {} for k in self._meta.storages
        }
        self._storage_attached: Dict[str, Set[int]] = {
            k: set() for k in self._meta.storages
        }
        self._storage_index_counter = 0
        # {container_name : _TestingPebbleClient}
        self._pebble_clients: Dict[str, _TestingPebbleClient] = {}
        self._pebble_clients_can_connect: Dict[_TestingPebbleClient, bool] = {}
        self._planned_units: Optional[int] = None
        self._hook_is_running = ""
        self._secrets: List[_Secret] = []
        self._opened_ports: Set[model.Port] = set()
        self._networks: Dict[Tuple[Optional[str], Optional[int]], _NetworkDict] = {}
        self._reboot_count = 0
        self._running_action: Optional[_RunningAction] = None
        self._cloud_spec: Optional[model.CloudSpec] = None

    def _can_connect(self, pebble_client: "_TestingPebbleClient") -> bool:
        """Returns whether the mock client is active and can support API calls with no errors."""
        return self._pebble_clients_can_connect[pebble_client]

    def _set_can_connect(self, pebble_client: "_TestingPebbleClient", val: bool):
        """Manually sets the can_connect state for the given mock client."""
        if pebble_client not in self._pebble_clients_can_connect:
            msg = 'cannot set can_connect for the client - are you running a "real" pebble test?'
            raise RuntimeError(msg)
        self._pebble_clients_can_connect[pebble_client] = val

    def _cleanup(self):
        if self._resource_dir is not None:
            self._resource_dir.cleanup()
            self._resource_dir = None
        self._harness_tmp_dir.cleanup()

    def _get_resource_dir(self) -> pathlib.Path:
        if self._resource_dir is None:
            # In actual Juju, the resource path for a charm's resource is
            # $AGENT_DIR/resources/$RESOURCE_NAME/$RESOURCE_FILENAME
            # However, charms shouldn't depend on this.
            self._resource_dir = tempfile.TemporaryDirectory(
                prefix="tmp-ops-test-resource-"
            )
        res_dir_name = cast(str, self._resource_dir.name)
        return pathlib.Path(res_dir_name)

    def relation_ids(self, relation_name: str) -> List[int]:
        try:
            return self._relation_ids_map[relation_name]
        except KeyError:
            if relation_name not in self._meta.relations:
                raise model.ModelError(
                    f"{relation_name} is not a known relation"
                ) from None
            no_ids: List[int] = []
            return no_ids

    def relation_list(self, relation_id: int):
        try:
            return self._relation_list_map[relation_id]
        except KeyError:
            raise model.RelationNotFoundError from None

    def relation_remote_app_name(self, relation_id: int) -> Optional[str]:
        if relation_id not in self._relation_app_and_units:
            # Non-existent or dead relation
            return None
        return self._relation_app_and_units[relation_id]["app"]

    def relation_get(self, relation_id: int, member_name: str, is_app: bool):
        if is_app and "/" in member_name:
            member_name = member_name.split("/")[0]
        if relation_id not in self._relation_data_raw:
            raise model.RelationNotFoundError()
        return self._relation_data_raw[relation_id][member_name]

    def update_relation_data(
        self,
        relation_id: int,
        _entity: Union[model.Unit, model.Application],
        key: str,
        value: str,
    ):
        # this is where the 'real' backend would call relation-set.
        raw_data = self._relation_data_raw[relation_id][_entity.name]
        if value == "":
            raw_data.pop(key, None)
        else:
            raw_data[key] = value

    def relation_set(self, relation_id: int, key: str, value: str, is_app: bool):
        if not isinstance(is_app, bool):
            raise TypeError("is_app parameter to relation_set must be a boolean")

        if (
            "relation_broken" in self._hook_is_running
            and not self.relation_remote_app_name(relation_id)
        ):
            raise RuntimeError(
                "remote-side relation data cannot be accessed during a relation-broken event"
            )

        if relation_id not in self._relation_data_raw:
            raise RelationNotFoundError(relation_id)

        relation = self._relation_data_raw[relation_id]
        bucket_key = self.app_name if is_app else self.unit_name
        if bucket_key not in relation:
            relation[bucket_key] = {}
        bucket = relation[bucket_key]
        if value == "":
            bucket.pop(key, None)
        else:
            bucket[key] = value

    def config_get(self) -> _TestingConfig:
        return self._config

    def is_leader(self):
        return self._is_leader

    def application_version_set(self, version: str):
        self._workload_version = version

    def resource_get(self, resource_name: str):
        if resource_name not in self._resources_map:
            raise model.ModelError(
                "ERROR could not download resource: HTTP request failed: "
                "Get https://.../units/unit-{}/resources/{}: resource#{}/{} not found".format(
                    self.unit_name.replace("/", "-"),
                    resource_name,
                    self.app_name,
                    resource_name,
                )
            )
        filename, contents = self._resources_map[resource_name]
        resource_dir = self._get_resource_dir()
        resource_filename = resource_dir / resource_name / filename
        if not resource_filename.exists():
            mode = "wb" if isinstance(contents, bytes) else "wt"
            resource_filename.parent.mkdir(exist_ok=True)
            with resource_filename.open(mode=mode) as resource_file:
                resource_file.write(contents)
        return resource_filename

    def pod_spec_set(self, spec: "model.K8sSpec", k8s_resources: Any):  # fixme: any
        self._pod_spec = (spec, k8s_resources)

    def status_get(self, *, is_app: bool = False):
        if is_app:
            return self._app_status
        else:
            return self._unit_status

    def status_set(
        self, status: "StatusName", message: str = "", *, is_app: bool = False
    ):
        if status in [model.ErrorStatus.name, model.UnknownStatus.name]:
            raise model.ModelError(
                f'ERROR invalid status "{status}", expected one of'
                " [maintenance blocked waiting active]"
            )
        if is_app:
            self._app_status = {"status": status, "message": message}
        else:
            self._unit_status = {"status": status, "message": message}

    def storage_list(self, name: str, include_detached: bool = False):
        """Returns a list of all attached storage mounts for the given storage name.

        Args:
            name: name (i.e. from metadata.yaml).
            include_detached: True to include unattached storage mounts as well.
        """
        return [
            index
            for index in self._storage_list[name]
            if include_detached or self._storage_is_attached(name, index)
        ]

    def storage_get(self, storage_name_id: str, attribute: str) -> Any:
        name, index = storage_name_id.split("/", 1)
        index = int(index)
        try:
            if index not in self._storage_attached[name]:
                raise KeyError()  # Pretend the key isn't there
            else:
                return self._storage_list[name][index][attribute]
        except KeyError:
            raise model.ModelError(
                f'ERROR invalid value "{name}/{index}" for option -s: storage not found'
            ) from None

    def storage_add(self, name: str, count: int = 1) -> List[int]:
        if "/" in name:
            raise model.ModelError('storage name cannot contain "/"')

        if name not in self._storage_list:
            self._storage_list[name] = {}
        result: List[int] = []
        for _ in range(count):
            index = self._storage_index_counter
            self._storage_index_counter += 1
            self._storage_list[name][index] = {
                "location": os.path.join(self._harness_storage_path, name, str(index)),
            }
            result.append(index)
        return result

    def _storage_detach(self, storage_id: str):
        # NOTE: This is an extra function for TestingModelBackend to simulate
        # detachment of a storage unit.  This is not present in ops.model._ModelBackend.
        name, index = storage_id.split("/", 1)
        index = int(index)

        for container, client in self._pebble_clients.items():
            for mount in self._meta.containers[container].mounts.values():
                if mount.storage != name:
                    continue
                root = client._root
                (root / mount.location[1:]).unlink()

        if self._storage_is_attached(name, index):
            self._storage_attached[name].remove(index)

    def _storage_attach(self, storage_id: str):
        """Mark the named storage_id as attached and return True if it was previously detached."""
        # NOTE: This is an extra function for TestingModelBackend to simulate
        # re-attachment of a storage unit.  This is not present in
        # ops.model._ModelBackend.
        name, index = storage_id.split("/", 1)

        for container, client in self._pebble_clients.items():
            for mount in self._meta.containers[container].mounts.values():
                if mount.storage != name:
                    continue
                for store in self._storage_list[mount.storage].values():
                    root = client._root
                    mounting_dir = root / mount.location[1:]
                    mounting_dir.parent.mkdir(parents=True, exist_ok=True)
                    target_dir = pathlib.Path(store["location"])
                    target_dir.mkdir(parents=True, exist_ok=True)
                    try:
                        mounting_dir.symlink_to(target_dir, target_is_directory=True)
                    except FileExistsError:
                        # If the symlink is already the one we want, then we
                        # don't need to do anything here.
                        # NOTE: In Python 3.9, this can use `mounting_dir.readlink()`
                        if not mounting_dir.is_symlink() or os.readlink(
                            mounting_dir
                        ) != str(target_dir):
                            raise

        index = int(index)
        if not self._storage_is_attached(name, index):
            self._storage_attached[name].add(index)
            return True
        return False

    def _storage_is_attached(self, storage_name: str, storage_index: int):
        return storage_index in self._storage_attached[storage_name]

    def _storage_remove(self, storage_id: str):
        # NOTE: This is an extra function for TestingModelBackend to simulate
        # full removal of a storage unit.  This is not present in
        # ops.model._ModelBackend.
        self._storage_detach(storage_id)
        name, index = storage_id.split("/", 1)
        index = int(index)
        self._storage_list[name].pop(index, None)

    def action_get(self) -> Dict[str, Any]:
        params: Dict[str, Any] = {}
        assert self._running_action is not None
        action_meta = self._meta.actions[self._running_action.name]
        for name, meta in action_meta.parameters.items():
            if "default" in meta:
                params[name] = meta["default"]
        params.update(self._running_action.parameters)
        return params

    def action_set(self, results: Dict[str, Any]):
        assert self._running_action is not None
        for key in ("stdout", "stderr", "stdout-encoding", "stderr-encoding"):
            if key in results:
                # Match Juju's error message.
                raise model.ModelError(f'ERROR cannot set reserved action key "{key}"')
        # Although it's not necessary, we go through the same flattening process
        # as the real backend, in order to give Charmers advance notice if they
        # are setting results that will not work.
        # This also does some validation on keys to make sure that they fit the
        # Juju constraints.
        model._format_action_result_dict(
            results
        )  # Validate, but ignore returned value.
        self._running_action.output.results.update(results)

    def action_log(self, message: str):
        assert self._running_action is not None
        self._running_action.output.logs.append(message)

    def action_fail(self, message: str = ""):
        assert self._running_action is not None
        # If fail is called multiple times, Juju only retains the most recent failure message.
        self._running_action.failure_message = message

    def network_get(
        self, endpoint_name: str, relation_id: Optional[int] = None
    ) -> "_NetworkDict":
        data = self._networks.get((endpoint_name, relation_id))
        if data is not None:
            return data
        if relation_id is not None:
            # Fall back to the default binding for this endpoint
            data = self._networks.get((endpoint_name, None))
            if data is not None:
                return data
        # No custom data per relation ID or binding, return the default binding
        data = self._networks.get((None, None))
        if data is not None:
            return data
        raise RelationNotFoundError

    def add_metrics(self, metrics, labels=None):  # type:ignore
        raise NotImplementedError(self.add_metrics)  # type:ignore

    @classmethod
    def log_split(cls, message, max_len=model.MAX_LOG_LINE_LEN):  # type:ignore
        raise NotImplementedError(cls.log_split)  # type:ignore

    def juju_log(self, level, msg):  # type:ignore
        raise NotImplementedError(self.juju_log)  # type:ignore

    def get_pebble(self, socket_path: str) -> "_TestingPebbleClient":
        container = socket_path.split("/")[
            3
        ]  # /charm/containers/<container_name>/pebble.socket
        client = self._pebble_clients.get(container, None)
        if client is None:
            container_root = self._harness_container_path / container
            container_root.mkdir()
            client = _TestingPebbleClient(self, container_root=container_root)

            # we need to know which container a new pebble client belongs to
            # so we can figure out which storage mounts must be simulated on
            # this pebble client's mock file systems when storage is
            # attached/detached later.
            self._pebble_clients[container] = client

        self._pebble_clients_can_connect[client] = False
        return client

    def planned_units(self) -> int:
        """Simulate fetching the number of planned application units from the model.

        If self._planned_units is None, then we simulate what the Juju controller will do, which is
        to report the number of peers, plus one (we include this unit in the count). This can be
        overridden for testing purposes: a charm author can set the number of planned units
        explicitly by calling `Harness.set_planned_units`
        """
        if self._planned_units is not None:
            return self._planned_units

        units: Set[str] = set()
        peer_names: Set[str] = set(self._meta.peers.keys())
        for peer_id, peer_name in self._relation_names.items():
            if peer_name not in peer_names:
                continue
            peer_units = self._relation_list_map[peer_id]
            units.update(peer_units)

        return len(units) + 1  # Account for this unit.

    def _get_secret(self, id: str) -> Optional[_Secret]:
        return next(
            (s for s in self._secrets if self._secret_ids_are_equal(s.id, id)), None
        )

    def _ensure_secret(self, id: str) -> _Secret:
        secret = self._get_secret(id)
        if secret is None:
            raise model.SecretNotFoundError(f"Secret {id!r} not found")
        return secret

    def _ensure_secret_id_or_label(self, id: Optional[str], label: Optional[str]):
        secret = None
        if id is not None:
            secret = self._get_secret(id)
            if secret is not None and label is not None:
                secret.label = label  # both id and label given, update label
        if secret is None and label is not None:
            secret = next((s for s in self._secrets if s.label == label), None)
        if secret is None:
            raise model.SecretNotFoundError(
                f"Secret not found by ID ({id!r}) or label ({label!r})"
            )
        return secret

    def _secret_ids_are_equal(self, id1: str, id2: str) -> bool:
        secret_re = re.compile(
            r"^(?:secret:)?(?://)?(?:(?P<uuid>[a-z0-9-]+)/)?(?P<id>[a-z0-9-]+)$",
            re.IGNORECASE,
        )
        mo = secret_re.match(id1)
        if not mo:
            return False
        model_uuid1 = mo.group("uuid") or self.model_uuid
        id1 = mo.group("id")
        mo = secret_re.match(id2)
        if not mo:
            return False
        model_uuid2 = mo.group("uuid") or self.model_uuid
        id2 = mo.group("id")
        return model_uuid1 == model_uuid2 and id1 == id2

    def secret_get(
        self,
        *,
        id: Optional[str] = None,
        label: Optional[str] = None,
        refresh: bool = False,
        peek: bool = False,
    ) -> Dict[str, str]:
        secret = self._ensure_secret_id_or_label(id, label)

        if secret.owner_name == self.model_uuid:
            # This is a user secret - charms only ever have view access.
            if self.app_name not in secret.user_secrets_grants:
                raise model.SecretNotFoundError(
                    f"Secret {id!r} not granted access to {self.app_name!r}"
                )
        elif secret.owner_name not in [self.app_name, self.unit_name]:
            # This is a model secret - the model might have admin or view access.
            # Check that caller has permission to get this secret
            # Observer is calling: does secret have a grant on relation between
            # this charm (the observer) and the secret owner's app?
            owner_app = secret.owner_name.split("/")[0]
            relation_id = self._relation_id_to(owner_app)
            if relation_id is None:
                raise model.SecretNotFoundError(
                    f"Secret {id!r} does not have relation to {owner_app!r}"
                )
            grants = secret.grants.get(relation_id, set())
            if self.app_name not in grants and self.unit_name not in grants:
                raise model.SecretNotFoundError(
                    f"Secret {id!r} not granted access to {self.app_name!r} or {self.unit_name!r}"
                )

        if peek or refresh:
            revision = secret.revisions[-1]
            if refresh:
                secret.tracked = revision.revision
        else:
            revision = next(
                (r for r in secret.revisions if r.revision == secret.tracked), None
            )
            if revision is None:
                raise model.SecretNotFoundError(
                    f"Secret {id!r} tracked revision was removed"
                )

        return revision.content

    def _relation_id_to(self, remote_app: str) -> Optional[int]:
        """Return relation ID of relation from charm's app to remote app."""
        for relation_id, app_units in self._relation_app_and_units.items():
            if app_units["app"] == remote_app:
                return relation_id
        return None

    def _has_secret_owner_permission(self, secret: _Secret) -> bool:
        # For unit secrets, the owner unit has manage permissions. For app
        # secrets, the leader has manage permissions and other units only have
        # view permissions.
        # https://discourse.charmhub.io/t/secret-access-permissions/12627
        # For user secrets the secret owner is the model, that is,
        # when `secret.owner_name == self.model.uuid`, only model admins have
        # manage permissions: https://juju.is/docs/juju/secret.

        unit_secret = secret.owner_name == self.unit_name
        app_secret = secret.owner_name == self.app_name

        return unit_secret or (app_secret and self.is_leader())

    def secret_info_get(
        self, *, id: Optional[str] = None, label: Optional[str] = None
    ) -> model.SecretInfo:
        secret = self._ensure_secret_id_or_label(id, label)
        if not self._has_secret_owner_permission(secret):
            raise model.SecretNotFoundError(
                f"You must own secret {secret.id!r} to perform this operation"
            )

        rotates = None
        rotation = None
        if secret.rotate_policy is not None:
            rotation = model.SecretRotate(secret.rotate_policy)
            if secret.rotate_policy != model.SecretRotate.NEVER:
                # Just set a fake rotation time some time in the future
                rotates = datetime.datetime.now() + datetime.timedelta(days=1)

        return model.SecretInfo(
            id=secret.id,
            label=secret.label,
            revision=secret.tracked,
            expires=secret.expire_time,
            rotation=rotation,
            rotates=rotates,
            description=secret.description,
            model_uuid=self.model_uuid,
        )

    def secret_set(
        self,
        id: str,
        *,
        content: Optional[Dict[str, str]] = None,
        label: Optional[str] = None,
        description: Optional[str] = None,
        expire: Optional[datetime.datetime] = None,
        rotate: Optional[model.SecretRotate] = None,
    ) -> None:
        secret = self._ensure_secret(id)
        if not self._has_secret_owner_permission(secret):
            raise RuntimeError(
                f"You must own secret {secret.id!r} to perform this operation"
            )

        if content is None:
            content = secret.revisions[-1].content
        revision = _SecretRevision(
            revision=secret.revisions[-1].revision + 1, content=content
        )
        secret.revisions.append(revision)
        if label is not None:
            if label:
                secret.label = label
            else:
                secret.label = None  # clear label
        if description is not None:
            if description:
                secret.description = description
            else:
                secret.description = None  # clear description
        if expire is not None:
            secret.expire_time = expire
        if rotate is not None:
            if rotate != model.SecretRotate.NEVER:
                secret.rotate_policy = rotate.value
            else:
                secret.rotate_policy = None  # clear rotation policy

    @classmethod
    def _generate_secret_id(cls) -> str:
        # Not a proper Juju secrets-style xid, but that's okay
        return f"secret:{uuid.uuid4()}"

    def secret_add(
        self,
        content: Dict[str, str],
        *,
        label: Optional[str] = None,
        description: Optional[str] = None,
        expire: Optional[datetime.datetime] = None,
        rotate: Optional[model.SecretRotate] = None,
        owner: Optional[str] = None,
    ) -> str:
        owner_name = self.unit_name if owner == "unit" else self.app_name
        return self._secret_add(
            content,
            owner_name,
            label=label,
            description=description,
            expire=expire,
            rotate=rotate,
        )

    def _secret_add(
        self,
        content: Dict[str, str],
        owner_name: str,
        *,
        label: Optional[str] = None,
        description: Optional[str] = None,
        expire: Optional[datetime.datetime] = None,
        rotate: Optional[model.SecretRotate] = None,
    ) -> str:
        id = self._generate_secret_id()
        revision = _SecretRevision(
            revision=1,
            content=content,
        )
        secret = _Secret(
            id=id,
            owner_name=owner_name,
            revisions=[revision],
            rotate_policy=rotate.value if rotate is not None else None,
            expire_time=expire,
            label=label,
            description=description,
        )
        self._secrets.append(secret)
        return id  # Note that this is the 'short' ID, not the canonicalised one.

    def secret_grant(
        self, id: str, relation_id: int, *, unit: Optional[str] = None
    ) -> None:
        secret = self._ensure_secret(id)
        if not self._has_secret_owner_permission(secret):
            raise model.SecretNotFoundError(
                f"You must own secret {secret.id!r} to perform this operation"
            )

        if relation_id not in secret.grants:
            secret.grants[relation_id] = set()
        remote_app_name = self._relation_app_and_units[relation_id]["app"]
        secret.grants[relation_id].add(unit or remote_app_name)

    def secret_revoke(
        self, id: str, relation_id: int, *, unit: Optional[str] = None
    ) -> None:
        secret = self._ensure_secret(id)
        if not self._has_secret_owner_permission(secret):
            raise RuntimeError(
                f"You must own secret {secret.id!r} to perform this operation"
            )

        if relation_id not in secret.grants:
            return
        remote_app_name = self._relation_app_and_units[relation_id]["app"]
        secret.grants[relation_id].discard(unit or remote_app_name)

    def secret_remove(self, id: str, *, revision: Optional[int] = None) -> None:
        secret = self._ensure_secret(id)
        if not self._has_secret_owner_permission(secret):
            raise RuntimeError(
                f"You must own secret {secret.id!r} to perform this operation"
            )

        if revision is not None:
            revisions = [r for r in secret.revisions if r.revision != revision]
            if len(revisions) == len(secret.revisions):
                raise model.SecretNotFoundError(
                    f"Secret {id!r} revision {revision} not found"
                )
            if revisions:
                secret.revisions = revisions
            else:
                # Last revision removed, remove entire secret
                self._secrets = [
                    s for s in self._secrets if not self._secret_ids_are_equal(s.id, id)
                ]
        else:
            self._secrets = [
                s for s in self._secrets if not self._secret_ids_are_equal(s.id, id)
            ]

    def open_port(self, protocol: str, port: Optional[int] = None):
        self._check_protocol_and_port(protocol, port)
        protocol_lit = cast(Literal["tcp", "udp", "icmp"], protocol)
        self._opened_ports.add(model.Port(protocol_lit, port))

    def close_port(self, protocol: str, port: Optional[int] = None):
        self._check_protocol_and_port(protocol, port)
        protocol_lit = cast(Literal["tcp", "udp", "icmp"], protocol)
        self._opened_ports.discard(model.Port(protocol_lit, port))

    def opened_ports(self) -> Set[model.Port]:
        return set(self._opened_ports)

    def _check_protocol_and_port(self, protocol: str, port: Optional[int]):
        # Simulate the error messages we get from Juju (not that charm tests
        # should be testing details of error messages).
        if protocol == "icmp":
            if port is not None:
                raise model.ModelError(
                    f'ERROR protocol "{protocol}" doesn\'t support any ports; got "{port}"\n'
                )
        elif protocol in ["tcp", "udp"]:
            if port is None:
                raise model.ModelError(
                    f'ERROR invalid port "{protocol}": '
                    f'strconv.Atoi: parsing "{protocol}": invalid syntax\n'
                )
            if not (1 <= port <= 65535):
                raise model.ModelError(
                    f"ERROR port range bounds must be between 1 and 65535, got {port}-{port}\n"
                )
        else:
            raise model.ModelError(
                f'ERROR invalid protocol "{protocol}", expected "tcp", "udp", or "icmp"\n'
            )

    def reboot(self, now: bool = False):
        self._reboot_count += 1
        if not now:
            return
        # This should exit, reboot, and re-emit the event, but we'll need the caller
        # to handle everything after the exit.
        raise SystemExit()

    def credential_get(self) -> model.CloudSpec:
        if not self._cloud_spec:
            raise model.ModelError(
                "ERROR cloud spec is empty, set it with `Harness.set_cloud_spec()` first"
            )
        return self._cloud_spec


class _TestingExecProcess:
    def __init__(
        self,
        command: List[str],
        timeout: Optional[float],
        exit_code: Optional[int],
        stdin: Union[TextIO, BinaryIO, None],
        stdout: Union[TextIO, BinaryIO, None],
        stderr: Union[TextIO, BinaryIO, None],
        is_timeout: bool,
    ):
        self._command = command
        self._timeout = timeout
        self._is_timeout = is_timeout
        if exit_code is None and not is_timeout:
            raise ValueError("when is_timeout is False, exit_code must not be None")
        self._exit_code = exit_code
        self.stdin = stdin
        self.stdout = stdout
        self.stderr = stderr

    def wait(self):
        if self._is_timeout:
            raise pebble.TimeoutError(
                f"timed out waiting for change ({self._timeout} seconds)"
            )
        if self._exit_code != 0:
            raise pebble.ExecError(
                self._command, cast(int, self._exit_code), None, None
            )

    def wait_output(self) -> Tuple[AnyStr, Optional[AnyStr]]:
        if self._is_timeout:
            raise pebble.TimeoutError(
                f"timed out waiting for change ({self._timeout} seconds)"
            )
        out_value = self.stdout.read() if self.stdout is not None else None
        err_value = self.stderr.read() if self.stderr is not None else None
        if self._exit_code != 0:
            raise pebble.ExecError[AnyStr](
                self._command,
                cast(int, self._exit_code),
                cast(Union[AnyStr, None], out_value),
                cast(Union[AnyStr, None], err_value),
            )
        return cast(AnyStr, out_value), cast(Union[AnyStr, None], err_value)

    def send_signal(self, sig: Union[int, str]):
        # the process is always terminated when ExecProcess is return in the simulation.
        raise BrokenPipeError("[Errno 32] Broken pipe")


class _TestingPebbleClient:
    """This conforms to the interface for pebble.Client but provides canned data.

    DO NOT use this class directly, it is used by `Harness`_ to run interactions with Pebble.
    `Harness`_ is responsible for maintaining the internal consistency of the values here,
    as the only public methods of this type are for implementing Client.
    """

    def __init__(self, backend: TestingModelBackend, container_root: pathlib.Path):
        self._backend = TestingModelBackend
        self._layers: Dict[str, pebble.Layer] = {}
        # Has a service been started/stopped?
        self._service_status: Dict[str, pebble.ServiceStatus] = {}
        self._root = container_root
        self._backend = backend
        self._exec_handlers: Dict[Tuple[str, ...], ExecHandler] = {}
        self._notices: Dict[Tuple[str, str], pebble.Notice] = {}
        self._last_notice_id = 0
        self._changes: Dict[str, pebble.Change] = {}
        self._check_infos: Dict[str, pebble.CheckInfo] = {}

    def _handle_exec(self, command_prefix: Sequence[str], handler: ExecHandler):
        prefix = tuple(command_prefix)
        self._exec_handlers[prefix] = handler

    def _check_connection(self):
        if not self._backend._can_connect(self):
            msg = (
                "Cannot connect to Pebble; did you forget to call "
                "begin_with_initial_hooks() or set_can_connect()?"
            )
            raise pebble.ConnectionError(msg)

    def get_system_info(self) -> pebble.SystemInfo:
        self._check_connection()
        return pebble.SystemInfo(version="1.0.0")

    def get_warnings(
        self,
        select: pebble.WarningState = pebble.WarningState.PENDING,
    ) -> List["pebble.Warning"]:
        raise NotImplementedError(self.get_warnings)

    def ack_warnings(self, timestamp: datetime.datetime) -> int:
        raise NotImplementedError(self.ack_warnings)

    def get_changes(
        self,
        select: pebble.ChangeState = pebble.ChangeState.IN_PROGRESS,
        service: Optional[str] = None,
    ) -> List[pebble.Change]:
        raise NotImplementedError(self.get_changes)

    def get_change(self, change_id: str) -> pebble.Change:
        self._check_connection()
        try:
            return self._changes[change_id]
        except KeyError:
            message = f'cannot find change with id "{change_id}"'
            raise self._api_error(404, message) from None

    def abort_change(self, change_id: pebble.ChangeID) -> pebble.Change:
        raise NotImplementedError(self.abort_change)

    def autostart_services(self, timeout: float = 30.0, delay: float = 0.1):
        self._check_connection()
        for name, service in self._render_services().items():
            # TODO: jam 2021-04-20 This feels awkward that Service.startup might be a string or
            #  might be an enum. Probably should make Service.startup a property rather than an
            #  attribute.
            if service.startup == "":
                startup = pebble.ServiceStartup.DISABLED
            else:
                startup = pebble.ServiceStartup(service.startup)
            if startup == pebble.ServiceStartup.ENABLED:
                self._service_status[name] = pebble.ServiceStatus.ACTIVE

    def replan_services(self, timeout: float = 30.0, delay: float = 0.1):
        return self.autostart_services(timeout, delay)

    def start_services(
        self,
        services: List[str],
        timeout: float = 30.0,
        delay: float = 0.1,
    ):
        # A common mistake is to pass just the name of a service, rather than a list of services,
        # so trap that so it is caught quickly.
        if isinstance(services, str):
            raise TypeError(
                f'start_services should take a list of names, not just "{services}"'
            )

        self._check_connection()

        # Note: jam 2021-04-20 We don't implement ChangeID, but the default caller of this is
        # Container.start() which currently ignores the return value
        known_services = self._render_services()
        # Names appear to be validated before any are activated, so do two passes
        for name in services:
            if name not in known_services:
                # TODO: jam 2021-04-20 This needs a better error type
                raise RuntimeError(f'400 Bad Request: service "{name}" does not exist')
        for name in services:
            self._service_status[name] = pebble.ServiceStatus.ACTIVE

    def stop_services(
        self,
        services: List[str],
        timeout: float = 30.0,
        delay: float = 0.1,
    ):
        # handle a common mistake of passing just a name rather than a list of names
        if isinstance(services, str):
            raise TypeError(
                f'stop_services should take a list of names, not just "{services}"'
            )

        self._check_connection()

        # Note: jam 2021-04-20 We don't implement ChangeID, but the default caller of this is
        # Container.stop() which currently ignores the return value
        known_services = self._render_services()
        for name in services:
            if name not in known_services:
                # TODO: jam 2021-04-20 This needs a better error type
                #  400 Bad Request: service "bal" does not exist
                raise RuntimeError(f'400 Bad Request: service "{name}" does not exist')
        for name in services:
            self._service_status[name] = pebble.ServiceStatus.INACTIVE

    def restart_services(
        self,
        services: List[str],
        timeout: float = 30.0,
        delay: float = 0.1,
    ):
        # handle a common mistake of passing just a name rather than a list of names
        if isinstance(services, str):
            raise TypeError(
                f'restart_services should take a list of names, not just "{services}"'
            )

        self._check_connection()

        # Note: jam 2021-04-20 We don't implement ChangeID, but the default caller of this is
        # Container.restart() which currently ignores the return value
        known_services = self._render_services()
        for name in services:
            if name not in known_services:
                # TODO: jam 2021-04-20 This needs a better error type
                #  400 Bad Request: service "bal" does not exist
                raise RuntimeError(f'400 Bad Request: service "{name}" does not exist')
        for name in services:
            self._service_status[name] = pebble.ServiceStatus.ACTIVE

    def wait_change(
        self,
        change_id: pebble.ChangeID,
        timeout: float = 30.0,
        delay: float = 0.1,
    ) -> pebble.Change:
        raise NotImplementedError(self.wait_change)

    def add_layer(
        self,
        label: str,
        layer: Union[str, "pebble.LayerDict", pebble.Layer],
        *,
        combine: bool = False,
    ):
        # I wish we could combine some of this helpful object corralling with the actual backend,
        # rather than having to re-implement it. Maybe we could subclass
        if not isinstance(label, str):
            raise TypeError(f"label must be a str, not {type(label).__name__}")

        if isinstance(layer, (str, dict)):
            layer_obj = pebble.Layer(layer)
        elif isinstance(layer, pebble.Layer):
            layer_obj = layer
        else:
            raise TypeError(
                f"layer must be str, dict, or pebble.Layer, not {type(layer).__name__}"
            )

        self._check_connection()

        if label in self._layers:
            if not combine:
                raise RuntimeError(f'400 Bad Request: layer "{label}" already exists')
            layer = self._layers[label]

            for name, service in layer_obj.services.items():
                # 'override' is actually single quoted in the real error, but
                # it shouldn't be, hopefully that gets cleaned up.
                if not service.override:
                    raise RuntimeError(
                        f'500 Internal Server Error: layer "{label}" must define'
                        f'"override" for service "{name}"'
                    )
                if service.override not in ("merge", "replace"):
                    raise RuntimeError(
                        f'500 Internal Server Error: layer "{label}" has invalid '
                        f'"override" value on service "{name}"'
                    )
                elif service.override == "replace":
                    layer.services[name] = service
                elif service.override == "merge":
                    if combine and name in layer.services:
                        layer.services[name]._merge(service)
                    else:
                        layer.services[name] = service

            for name, check in layer_obj.checks.items():
                if not check.override:
                    raise RuntimeError(
                        f'500 Internal Server Error: layer "{label}" must define'
                        f'"override" for check "{name}"'
                    )
                if check.override not in ("merge", "replace"):
                    raise RuntimeError(
                        f'500 Internal Server Error: layer "{label}" has invalid '
                        f'"override" value for check "{name}"'
                    )
                elif check.override == "replace":
                    layer.checks[name] = check
                elif check.override == "merge":
                    if combine and name in layer.checks:
                        layer.checks[name]._merge(check)
                    else:
                        layer.checks[name] = check

            for name, log_target in layer_obj.log_targets.items():
                if not log_target.override:
                    raise RuntimeError(
                        f'500 Internal Server Error: layer "{label}" must define'
                        f'"override" for log target "{name}"'
                    )
                if log_target.override not in ("merge", "replace"):
                    raise RuntimeError(
                        f'500 Internal Server Error: layer "{label}" has invalid '
                        f'"override" value for log target "{name}"'
                    )
                elif log_target.override == "replace":
                    layer.log_targets[name] = log_target
                elif log_target.override == "merge":
                    if combine and name in layer.log_targets:
                        layer.log_targets[name]._merge(log_target)
                    else:
                        layer.log_targets[name] = log_target

        else:
            self._layers[label] = layer_obj

    def _render_services(self) -> Dict[str, pebble.Service]:
        services: Dict[str, pebble.Service] = {}
        for key in sorted(self._layers.keys()):
            layer = self._layers[key]
            for name, service in layer.services.items():
                # TODO: merge existing services https://github.com/canonical/operator/issues/1112
                services[name] = service
        return services

    def _render_checks(self) -> Dict[str, pebble.Check]:
        checks: Dict[str, pebble.Check] = {}
        for key in sorted(self._layers.keys()):
            layer = self._layers[key]
            for name, check in layer.checks.items():
                checks[name] = check
        return checks

    def _render_log_targets(self) -> Dict[str, pebble.LogTarget]:
        log_targets: Dict[str, pebble.LogTarget] = {}
        for key in sorted(self._layers.keys()):
            layer = self._layers[key]
            for name, log_target in layer.log_targets.items():
                log_targets[name] = log_target
        return log_targets

    def get_plan(self) -> pebble.Plan:
        self._check_connection()
        plan = pebble.Plan("{}")
        plan.services.update(self._render_services())
        plan.checks.update(self._render_checks())
        plan.log_targets.update(self._render_log_targets())
        return plan

    def get_services(
        self, names: Optional[List[str]] = None
    ) -> List[pebble.ServiceInfo]:
        if isinstance(names, str):
            raise TypeError(
                f'start_services should take a list of names, not just "{names}"'
            )

        self._check_connection()
        services = self._render_services()
        infos: List[pebble.ServiceInfo] = []
        if names is None:
            names = sorted(services.keys())
        for name in sorted(names):
            try:
                service = services[name]
            except KeyError:
                # in pebble, it just returns "nothing matched" if there are 0 matches,
                # but it ignores services it doesn't recognize
                continue
            status = self._service_status.get(name, pebble.ServiceStatus.INACTIVE)
            if service.startup == "":
                startup = pebble.ServiceStartup.DISABLED
            else:
                startup = pebble.ServiceStartup(service.startup)
            info = pebble.ServiceInfo(
                name, startup=startup, current=pebble.ServiceStatus(status)
            )
            infos.append(info)
        return infos

    @staticmethod
    def _check_absolute_path(path: str):
        if not path.startswith("/"):
            raise pebble.PathError(
                "generic-file-error", f"paths must be absolute, got {path!r}"
            )

    def pull(
        self, path: str, *, encoding: Optional[str] = "utf-8"
    ) -> Union[BinaryIO, TextIO]:
        self._check_connection()
        self._check_absolute_path(path)
        file_path = self._root / path[1:]
        try:
            return cast(
                Union[BinaryIO, TextIO],
                file_path.open("rb" if encoding is None else "r", encoding=encoding),
            )
        except FileNotFoundError:
            raise pebble.PathError(
                "not-found", f"stat {path}: no such file or directory"
            ) from None
        except IsADirectoryError:
            raise pebble.PathError(
                "generic-file-error", f'can only read a regular file: "{path}"'
            ) from None

    def push(
        self,
        path: str,
        source: "ReadableBuffer",
        *,
        encoding: str = "utf-8",
        make_dirs: bool = False,
        permissions: Optional[int] = None,
        user_id: Optional[int] = None,
        user: Optional[str] = None,
        group_id: Optional[int] = None,
        group: Optional[str] = None,
    ) -> None:
        self._check_connection()
        if permissions is not None and not (0 <= permissions <= 0o777):
            raise pebble.PathError(
                "generic-file-error",
                f"permissions not within 0o000 to 0o777: {permissions:#o}",
            )
        self._check_absolute_path(path)
        file_path = self._root / path[1:]
        if make_dirs and not file_path.parent.exists():
            self.make_dir(
                os.path.dirname(path),
                make_parents=True,
                permissions=None,
                user_id=user_id,
                user=user,
                group_id=group_id,
                group=group,
            )
        permissions = permissions if permissions is not None else 0o644
        try:
            if isinstance(source, str):
                file_path.write_text(source, encoding=encoding)
            elif isinstance(source, bytes):
                file_path.write_bytes(source)
            else:
                # If source is binary, open file in binary mode and ignore encoding param
                is_binary = isinstance(source.read(0), bytes)  # type: ignore
                open_mode = "wb" if is_binary else "w"
                open_encoding = None if is_binary else encoding
                with file_path.open(open_mode, encoding=open_encoding) as f:
                    shutil.copyfileobj(cast(IOBase, source), cast(IOBase, f))
            os.chmod(file_path, permissions)
        except FileNotFoundError as e:
            raise pebble.PathError(
                "not-found", f"parent directory not found: {e.args[0]}"
            ) from None
        except NotADirectoryError:
            raise pebble.PathError(
                "generic-file-error", f"open {path}.~: not a directory"
            ) from None

    def list_files(
        self, path: str, *, pattern: Optional[str] = None, itself: bool = False
    ) -> List[pebble.FileInfo]:
        self._check_connection()
        self._check_absolute_path(path)
        file_path = self._root / path[1:]
        if not file_path.exists():
            raise self._api_error(404, f"stat {path}: no such file or directory")
        files = [file_path]
        if not itself:
            try:
                files = [file_path / file for file in os.listdir(file_path)]
            except NotADirectoryError:
                pass

        if pattern is not None:
            files = [file for file in files if fnmatch.fnmatch(file.name, pattern)]

        file_infos = [Container._build_fileinfo(file) for file in files]
        for file_info in file_infos:
            rel_path = os.path.relpath(file_info.path, start=self._root)
            rel_path = "/" if rel_path == "." else "/" + rel_path
            file_info.path = rel_path
            if rel_path == "/":
                file_info.name = "/"
        return file_infos

    def make_dir(
        self,
        path: str,
        *,
        make_parents: bool = False,
        permissions: Optional[int] = None,
        user_id: Optional[int] = None,
        user: Optional[str] = None,
        group_id: Optional[int] = None,
        group: Optional[str] = None,
    ) -> None:
        self._check_connection()
        if permissions is not None and not (0 <= permissions <= 0o777):
            raise pebble.PathError(
                "generic-file-error",
                f"permissions not within 0o000 to 0o777: {permissions:#o}",
            )
        self._check_absolute_path(path)
        dir_path = self._root / path[1:]
        if not dir_path.parent.exists() and not make_parents:
            raise pebble.PathError("not-found", f"parent directory not found: {path}")
        if not dir_path.parent.exists() and make_parents:
            self.make_dir(
                os.path.dirname(path),
                make_parents=True,
                permissions=permissions,
                user_id=user_id,
                user=user,
                group_id=group_id,
                group=group,
            )
        try:
            permissions = permissions if permissions else 0o755
            dir_path.mkdir()
            os.chmod(dir_path, permissions)
        except FileExistsError:
            if not make_parents:
                raise pebble.PathError(
                    "generic-file-error", f"mkdir {path}: file exists"
                ) from None
        except NotADirectoryError as e:
            # Attempted to create a subdirectory of a file
            raise pebble.PathError(
                "generic-file-error", f"not a directory: {e.args[0]}"
            ) from None

    def remove_path(self, path: str, *, recursive: bool = False):
        self._check_connection()
        self._check_absolute_path(path)
        file_path = self._root / path[1:]
        if not file_path.exists():
            if recursive:
                return
            raise pebble.PathError(
                "not-found", f"remove {path}: no such file or directory"
            )
        if file_path.is_dir():
            if recursive:
                shutil.rmtree(file_path)
            else:
                try:
                    file_path.rmdir()
                except OSError as e:
                    raise pebble.PathError(
                        "generic-file-error",
                        "cannot remove non-empty directory without recursive=True",
                    ) from e
        else:
            file_path.unlink()

    def _find_exec_handler(self, command: List[str]) -> Optional[ExecHandler]:
        for prefix_len in reversed(range(len(command) + 1)):
            command_prefix = tuple(command[:prefix_len])
            if command_prefix in self._exec_handlers:
                return self._exec_handlers[command_prefix]
        return None

    def _transform_exec_handler_output(
        self, data: Union[str, bytes], encoding: Optional[str]
    ) -> Union[io.BytesIO, io.StringIO]:
        if isinstance(data, bytes):
            if encoding is None:
                return io.BytesIO(data)
            else:
                return io.StringIO(data.decode(encoding=encoding))
        else:
            if encoding is None:
                raise ValueError(
                    f"exec handler must return bytes if encoding is None,"
                    f"not {data.__class__.__name__}"
                )
            else:
                return io.StringIO(typing.cast(str, data))

    def exec(
        self,
        command: List[str],
        *,
        service_context: Optional[str] = None,
        environment: Optional[Dict[str, str]] = None,
        working_dir: Optional[str] = None,
        timeout: Optional[float] = None,
        user_id: Optional[int] = None,
        user: Optional[str] = None,
        group_id: Optional[int] = None,
        group: Optional[str] = None,
        stdin: Optional[Union[str, bytes, TextIO, BinaryIO]] = None,
        stdout: Optional[Union[TextIO, BinaryIO]] = None,
        stderr: Optional[Union[TextIO, BinaryIO]] = None,
        encoding: Optional[str] = "utf-8",
        combine_stderr: bool = False,
    ) -> ExecProcess[Any]:
        self._check_connection()
        handler = self._find_exec_handler(command)
        if handler is None:
            message = "execution handler not found, please register one using Harness.handle_exec"
            raise self._api_error(500, message)
        environment = {} if environment is None else environment
        if service_context is not None:
            plan = self.get_plan()
            if service_context not in plan.services:
                message = f'context service "{service_context}" not found'
                raise self._api_error(500, message)
            service = plan.services[service_context]
            environment = {**service.environment, **environment}
            working_dir = service.working_dir if working_dir is None else working_dir
            user = service.user if user is None else user
            user_id = service.user_id if user_id is None else user_id
            group = service.group if group is None else group
            group_id = service.group_id if group_id is None else group_id

        if hasattr(stdin, "read"):
            stdin = stdin.read()  # type: ignore

        exec_args = ExecArgs(
            command=command,
            environment=environment,
            working_dir=working_dir,
            timeout=timeout,
            user_id=user_id,
            user=user,
            group_id=group_id,
            group=group,
            stdin=cast(Union[str, bytes, None], stdin),
            encoding=encoding,
            combine_stderr=combine_stderr,
        )
        proc_stdin = self._transform_exec_handler_output(b"", encoding)
        if stdin is not None:
            proc_stdin = None
        proc_stdout = self._transform_exec_handler_output(b"", encoding)
        proc_stderr = self._transform_exec_handler_output(b"", encoding)
        try:
            result = handler(exec_args)
        except TimeoutError:
            if timeout is not None:
                exec_process = _TestingExecProcess(
                    command=command,
                    timeout=timeout,
                    exit_code=None,
                    stdin=proc_stdin,
                    stdout=proc_stdout,
                    stderr=proc_stderr,
                    is_timeout=True,
                )
                return cast(pebble.ExecProcess[Any], exec_process)
            else:
                raise RuntimeError(
                    "a TimeoutError occurred in the execution handler, "
                    "but no timeout value was provided in the execution arguments."
                ) from None
        if result is None:
            exit_code = 0
            proc_stdout = self._transform_exec_handler_output(b"", encoding)
            proc_stderr = self._transform_exec_handler_output(b"", encoding)
        elif isinstance(result, ExecResult):
            exit_code = result.exit_code
            proc_stdout = self._transform_exec_handler_output(result.stdout, encoding)
            proc_stderr = self._transform_exec_handler_output(result.stderr, encoding)
        else:
            raise TypeError(
                f"execution handler returned an unexpected type: {type(result)!r}."
            )
        if combine_stderr and proc_stderr.getvalue():
            raise ValueError(
                "execution handler returned a non-empty stderr "
                "even though combine_stderr is enabled."
            )
        if stdout is not None:
            shutil.copyfileobj(cast(io.IOBase, proc_stdout), cast(io.IOBase, stdout))
            proc_stdout = None
        if stderr is not None:
            shutil.copyfileobj(cast(io.IOBase, proc_stderr), cast(io.IOBase, stderr))
            proc_stderr = None
        exec_process = _TestingExecProcess(
            command=command,
            timeout=timeout,
            exit_code=exit_code,
            stdin=proc_stdin,
            stdout=proc_stdout,
            stderr=proc_stderr,
            is_timeout=False,
        )
        return cast(pebble.ExecProcess[Any], exec_process)

    def send_signal(self, sig: Union[int, str], service_names: Iterable[str]):
        if not service_names:
            raise TypeError("send_signal expected at least 1 service name, got 0")
        self._check_connection()

        # Convert signal to str
        if isinstance(sig, int):
            sig = signal.Signals(sig).name

        # pebble first validates the service name, and then the signal name

        plan = self.get_plan()
        for service in service_names:
            if (
                service not in plan.services
                or not self.get_services([service])[0].is_running()
            ):
                # conform with the real pebble api
                message = f'cannot send signal to "{service}": service is not running'
                raise self._api_error(500, message)

        # Check if signal name is valid
        try:
            signal.Signals[sig]
        except KeyError:
            # conform with the real pebble api
            first_service = next(iter(service_names))
            message = (
                f'cannot send signal to "{first_service}": invalid signal name "{sig}"'
            )
            raise self._api_error(500, message) from None

    def get_checks(
        self,
        level: Optional[pebble.CheckLevel] = None,
        names: Optional[Iterable[str]] = None,
    ) -> List[pebble.CheckInfo]:
        if names is not None:
            names = frozenset(names)
        return [
            info
            for info in self._check_infos.values()
            if (level is None or level == info.level)
            and (names is None or info.name in names)
        ]

    def notify(
        self,
        type: pebble.NoticeType,
        key: str,
        *,
        data: Optional[Dict[str, str]] = None,
        repeat_after: Optional[datetime.timedelta] = None,
    ) -> str:
        notice_id, _ = self._notify(type, key, data=data, repeat_after=repeat_after)
        return notice_id

    def _notify(
        self,
        type: pebble.NoticeType,
        key: str,
        *,
        data: Optional[Dict[str, str]] = None,
        repeat_after: Optional[datetime.timedelta] = None,
    ) -> Tuple[str, bool]:
        """Record an occurrence of a notice with the specified details.

        Return a tuple of (notice_id, new_or_repeated).
        """
        # The shape of the code below is taken from State.AddNotice in Pebble.
        now = datetime.datetime.now(tz=datetime.timezone.utc)

        new_or_repeated = False
        unique_key = (type.value, key)
        notice = self._notices.get(unique_key)
        if notice is None:
            # First occurrence of this notice uid+type+key
            self._last_notice_id += 1
            notice = pebble.Notice(
                id=str(self._last_notice_id),
                user_id=0,  # Charm should always be able to read pebble_notify notices.
                type=type,
                key=key,
                first_occurred=now,
                last_occurred=now,
                last_repeated=now,
                expire_after=datetime.timedelta(days=7),
                occurrences=1,
                last_data=data or {},
                repeat_after=repeat_after,
            )
            self._notices[unique_key] = notice
            new_or_repeated = True
        else:
            # Additional occurrence, update existing notice
            last_repeated = notice.last_repeated
            if repeat_after is None or now > notice.last_repeated + repeat_after:
                # Update last repeated time if repeat-after time has elapsed (or is None)
                last_repeated = now
                new_or_repeated = True
            notice = dataclasses.replace(
                notice,
                last_occurred=now,
                last_repeated=last_repeated,
                occurrences=notice.occurrences + 1,
                last_data=data or {},
                repeat_after=repeat_after,
            )
            self._notices[unique_key] = notice

        return notice.id, new_or_repeated

    def _api_error(self, code: int, message: str) -> pebble.APIError:
        status = http.HTTPStatus(code).phrase
        body = {
            "type": "error",
            "status-code": code,
            "status": status,
            "result": {"message": message},
        }
        return pebble.APIError(body, code, status, message)

    def get_notice(self, id: str) -> pebble.Notice:
        for notice in self._notices.values():
            if notice.id == id:
                return notice
        raise self._api_error(404, f'cannot find notice with ID "{id}"')

    def get_notices(
        self,
        *,
        users: Optional[pebble.NoticesUsers] = None,
        user_id: Optional[int] = None,
        types: Optional[Iterable[Union[pebble.NoticeType, str]]] = None,
        keys: Optional[Iterable[str]] = None,
    ) -> List[pebble.Notice]:
        # Similar logic as api_notices.go:v1GetNotices in Pebble.

        filter_user_id = 0  # default is to filter by request UID (root)
        if user_id is not None:
            filter_user_id = user_id
        if users is not None:
            if user_id is not None:
                raise self._api_error(400, 'cannot use both "users" and "user_id"')
            filter_user_id = None

        if types is not None:
            types = {
                (t.value if isinstance(t, pebble.NoticeType) else t) for t in types
            }
        if keys is not None:
            keys = set(keys)

        notices = [
            notice
            for notice in self._notices.values()
            if self._notice_matches(notice, filter_user_id, types, keys)
        ]
        notices.sort(key=lambda notice: notice.last_repeated)
        return notices

    @staticmethod
    def _notice_matches(
        notice: pebble.Notice,
        user_id: Optional[int] = None,
        types: Optional[Set[str]] = None,
        keys: Optional[Set[str]] = None,
    ) -> bool:
        # Same logic as NoticeFilter.matches in Pebble.
        # For example: if user_id filter is set and it doesn't match, return False.
        if user_id is not None and not (
            notice.user_id is None or user_id == notice.user_id
        ):
            return False
        if types is not None and notice.type not in types:
            return False
        if keys is not None and notice.key not in keys:
            return False
        return True
